#!/bin/bash -e
FLAG=$1
INPUT=$2

# checks if any argument contains a file then assigns it to INPUT
if [ $# -ne 2 ]; then
    [ $# -ge 1 -a -f "$1" ] && INPUT="$1" || INPUT="-"
    cat $INPUT >> input.$$
    INPUT=input.$$
fi
# cannot stop or catch SIGKILL
trap "check_and_clean; exit 0" SIGINT SIGHUP SIGTERM
# look for improper usage
if [[ $FLAG != *-r* && $FLAG != *-c* ]] || [[ -z $FLAG && -z $INPUT ]]; then 
    echo -e "Usage: stats {-rows|-cols} [file]"
    exit 0
fi

# do the janitorial work
function check_and_clean {
    if ! [ -r $INPUT ]; then
        echo Cannot read $INPUT
        return 1
        exit
    fi
    rm -rf row.$$ median.$$ col.$$ sorted.$$
}
check_and_clean

if [[ $FLAG == *-r* ]]; then
 
    if ! [ -s $INPUT ]; then
        echo Average Median; exit 1
    fi
   # gets the rows
    echo Average Median
    cat $INPUT | while read -r line  || [[ -n "$line" ]]; do
        sum=0
        count=0
        # assign length to cols
        for i in $line; do
            sum=$(($sum + $i))
            echo $i >> row.$$
            count=$(($count + 1))
        done
        median_cnt=$(($count / 2))
        if [ $(($count % 2)) -eq 1 ]; then
            median_cnt=$(($count / 2 + 1))
        fi
        # write out to files sums and rows 
        SORTED=`cat row.$$ | sort -n`
        MEDIAN=`tail -n+$median_cnt row.$$ | head -n1`
        AVERAGE=$(echo "$sum/$count" | bc -l)
        printf "%.0f\t%d\n" $AVERAGE $MEDIAN 
        check_and_clean
    done
fi

if [[ $FLAG == *-c* ]]; then
    if ! [ -s $INPUT ]; then
        printf "Averages:\n\nMedians:\n"; exit 1
    fi
    count=0
    while read -r line; do
        count=$(($count + 1))
    done < $INPUT
    col_count=`cat $INPUT | awk 'BEGIN{FS=" "};{print NF;exit}'`
    # devide by 2 will work if even
    median_cnt=$(($count / 2))
    # catch if odd
    if [ $(($count % 2)) -eq 1 ]; then
        median_cnt=$(($count / 2 + 1))
    fi
    # assign each column to an element
    for i in $(seq 1 $col_count); do
        ARR[$i]=`awk '{ print $'$i' }' $INPUT`
    done
    # loop over each column
    for i in $(seq 1 $col_count); do
        sum=0
        # save the column into a file 
        echo "${ARR[i]}" > col.$$
        # add each element and save in sum
        for i in $(<col.$$); do
            sum=$(($sum + $i))
        done < col.$$
        # use bc for aritmatic 
        AVERAGE=$(echo "$sum/$count" | bc -l) 
        printf "%.0f " $AVERAGE >> averages.$$
        # sort the saved column numerically
        
        SORTED=`cat col.$$ | sort -n`
        echo $SORTED > sorted.$$

        echo "`tr ' ' '\n' < sorted.$$`" > med.$$
        MEDIAN=`sed -n ''$median_cnt'{p;q}' med.$$`
        echo $MEDIAN >> medians.$$
        # print floating point for rounding
        # clean up
        check_and_clean
        rm -rf med.$$
    done
    echo -e Averages:
    cat averages.$$
    printf "\nMedians:\n"
    while read -r line; do
        printf "%s\0 " $line
    done < medians.$$
    rm -rf averages.$$ medians.$$
fi
exit 0
